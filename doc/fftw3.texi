\input texinfo    @c -*-texinfo-*-
@comment $Id: fftw3.texi,v 1.24 2003-02-15 22:02:07 stevenj Exp $
@comment %**start of header
@setfilename fftw3.info
@include version.texi
@settitle FFTW @value{VERSION}
@setchapternewpage odd
@c define constant index (ct)
@defcodeindex ct
@syncodeindex ct fn
@syncodeindex vr fn
@syncodeindex pg fn
@syncodeindex tp fn
@c define foreign function index (ff)
@defcodeindex ff
@syncodeindex ff cp
@c define foreign constant index (fc)
@defcodeindex fc
@syncodeindex fc cp
@c define foreign program index (fp)
@defcodeindex fp
@syncodeindex fp cp
@comment %**end of header

@copying
This manual is for FFTW
(version @value{VERSION}, @value{UPDATED}).

Copyright @copyright{} 2002 Matteo Frigo.

Copyright @copyright{} 2002 Steven G. Johnson.

@quotation
Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end quotation
@end copying

@dircategory Texinfo documentation system
@direntry
* fftw3: (fftw3)FFTW User's Manual.
@end direntry

@titlepage
@title FFTW
@subtitle for version @value{VERSION}, @value{UPDATED}
@author{Matteo Frigo}
@author{Steven G. Johnson}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top, Introduction, (dir), (dir)
@top FFTW User Manual
Welcome to FFTW, the Fastest Fourier Transform in the West.  FFTW is a
collection of fast C routines to compute the discrete Fourier transform.
This manual documents FFTW version @value{VERSION}.
@end ifnottex

@menu
* Introduction::                
* Tutorial::                    
* Other Stuff You Should Know::  
* FFTW Reference::              
* Parallel FFTW::               
* Calling FFTW from Fortran::   
* Installation and Customization::  
* Acknowledgments::             
* License and Copyright::       
* Concept Index::               
* Library Index::               Tutorial


Other Stuff You Should Know

@end menu

@c ************************************************************
@node    Introduction, Tutorial, Top, Top
@chapter Introduction
This manual documents version @value{VERSION} of FFTW, the @emph{Fastest
Fourier Transform in the West}.  FFTW is a comprehensive collection of
fast C routines for computing the discrete Fourier transform (DFT) in
@cindex discrete Fourier transform
@cindex DFT
one or more dimensions, of both real and complex data, and of arbitrary
input size.  It also includes specialized transforms for real even/odd
data (a.k.a. discrete cosine/sine transforms), as well as the discrete
Hartley transform (DHT).  We assume herein that the reader is already
familiar with the properties and uses of the DFT that are relevant to
her application.  Otherwise, see e.g. @cite{The Fast Fourier Transform}
by E. O. Brigham (Prentice-Hall, Englewood Cliffs, NJ, 1974).
@uref{http://www.fftw.org, Our web page} also has links to FFT-related
information online.
@cindex FFTW

FFTW @value{VERSION} also includes parallel (multi-threaded) transforms
for shared-memory systems.  We currently provide distributed-memory
parallel (MPI) transforms separately, as part of FFTW 2.x.

FFTW is usually faster (and sometimes much faster) than all other
freely-available Fourier transform programs found on the Net.  It is
competitive with (and often faster than) the FFT codes in Sun's
Performance Library, IBM's ESSL library, HP's CXML library, and Intel's
MKL library, which are targeted at specific machines.  Moreover, FFTW's
performance is @emph{portable}.  Indeed, FFTW is unique in that it
automatically adapts itself to your machine, your cache, the size of
your memory, your number of registers, and all the other factors that
normally make it impossible to optimize a program for more than one
machine.  An extensive comparison of FFTW's performance with that of
other Fourier transform codes has been made, and the results are
available on the Web at @uref{http://fftw.org/~benchfft, the benchFFT
home page}.
@cindex benchmark
@fpindex benchfft

In order to use FFTW effectively, you need to understand one basic
concept of FFTW's internal structure:  FFTW does not used a fixed
algorithm for computing the transform, but instead can adapt the DFT
algorithm to details of the underlying hardware in order to achieve
the best performance.  Hence, the computation of the transform is
split into two phases.  First, FFTW's @dfn{planner} is called, which
``learns'' the fastest way to compute the transform on your machine.
The planner
@cindex planner
produces a data structure called a @dfn{plan} that contains this
@cindex plan
information.  Subsequently, the plan is @dfn{executed}
@cindex execute
to transform the array of input data as dictated by the plan.  The plan
can be reused as many times as needed.  In typical high-performance
applications, many transforms of the same size are computed, and
consequently a relatively-expensive initialization of this sort is
acceptable.  On the other hand, if you need a single transform of a
given size, the one-time cost of the planner becomes significant.  For
this case, FFTW provides fast planners based on heuristics or on
previously computed plans (``wisdom'').
@cindex wisdom

This pattern of planning/execution applies to all transform types
supported by FFTW; each type comes with its own planner routine to
specify the problem to be solved.  Because FFTW is very flexible in the
layout and multiplicity of the data to be transformed, these planner
routines are organized into three categories: the @dfn{basic interface}
for computing single transforms of contiguous data; the @dfn{advanced
interface} for efficient transforms of multiple/strided arrays; and the
@dfn{guru} interface, which supports the most general data
layouts/multiplicities/strides.  We expect that most users will be best
served by the basic interface, whereas the guru interface requires
careful attention to the documentation to avoid problems.
@cindex basic interface
@cindex advanced interface
@cindex guru interface 

Besides the automatic performance adaptation performed by the planner,
it is also possible for advanced users to customize FFTW for their
special needs.  For example, we provide a tool so that users who only
require a limited set of transform types/sizes can link to just those
parts of FFTW that are required for the optimal plans, greatly reducing
the size of statically linked executables.  Moreover, as distributed,
FFTW works most efficiently for arrays whose size can be factored into
small primes (@math{2}, @math{3}, @math{5}, and @math{7}), and uses a
slower general-purpose routine for other factors.  FFTW, however, comes
with a code generator that can produce fast C programs for any
particular array size you may care about.
@cindex code generator
For example, if you need transforms of size
@ifinfo
@math{513 = 19 x 3^3},
@end ifinfo
@tex
$513 = 19 \cdot 3^3$,
@end tex
@ifhtml
513&nbsp;=&nbsp;19*3<sup>3</sup>,
@end ifhtml
you can customize FFTW to support the factor @math{19} efficiently.

For more information regarding FFTW, see the paper, ``FFTW: An
adaptive software architecture for the FFT,'' by M. Frigo and
S. G. Johnson, which appeared in the 23rd International Conference on
Acoustics, Speech, and Signal Processing (@cite{Proc. ICASSP 1998}
@b{3}, p. 1381).  See also, ``The Fastest Fourier Transform in the
West,'' by M. Frigo and S. G. Johnson, which is the technical report
MIT-LCS-TR-728 (Sep. '97).  The code generator is described in the
paper ``A fast Fourier transform compiler'',
@cindex compiler
by M. Frigo, in the @cite{Proceedings of the 1999 ACM SIGPLAN Conference
on Programming Language Design and Implementation (PLDI), Atlanta,
Georgia, May 1999}.  These papers, along with the latest version of
FFTW, the FAQ, benchmarks, and other links, are available at
@uref{http://www.fftw.org, the FFTW home page}.  The current version of
FFTW incorporates many good ideas from the past thirty years of FFT
literature.  In one way or another, FFTW uses the Cooley-Tukey
algorithm, the Prime Factor algorithm, Rader's algorithm for prime
sizes, and the split-radix algorithm (with a variation due to Dan
Bernstein).  Our code generator also produces new algorithms that we do
not yet completely understand.
@cindex algorithm
The reader is referred to the cited papers for the appropriate
references.

The rest of this manual is organized as follows.  We first discuss the
sequential (one-processor) implementation.  We start by describing the
basic interface/features of FFTW in @ref{Tutorial}.  The following
chapter discusses @ref{Other Stuff You Should Know}, including
@ref{The Importance of Alignment}, the storage scheme of
multi-dimensional arrays (@ref{Multi-dimensional Array Format}), and
FFTW's mechanism for storing plans on disk (@ref{Words of Wisdom}).
Next, @ref{FFTW Reference} provides comprehensive documentation of all
FFTW's features.  Parallel transforms are discussed in their own
chapter @ref{Parallel FFTW}.  Fortran programmers can also use FFTW,
as described in @ref{Calling FFTW from Fortran}.  @ref{Installation
and Customization} explains how to install FFTW in your computer
system and how to adapt FFTW to your needs.  License and copyright
information is given in @ref{License and Copyright}.  Finally, we
thank all the people who helped us in @ref{Acknowledgments}.

@c ************************************************************
@node  Tutorial, Other Stuff You Should Know, Introduction, Top
@chapter Tutorial
@menu
* Complex One-Dimensional DFTs::  
* Complex Multi-Dimensional DFTs::  
* One-Dimensional DFTs of Real Data::  
* Multi-Dimensional DFTs of Real Data::  
* More DFTs of Real Data::      
@end menu

This chapter describes the basic usage of FFTW, i.e., how to compute
@cindex basic interface
the Fourier transform of a single array.  This chapter tells the
truth, but not the @emph{whole} truth. Specifically, FFTW implements
additional routines and flags that are not documented here, although
in many cases we try to indicate where added capabilities exist.  For
more complete information, see @ref{FFTW Reference}.  (Note that you
need to compile and install FFTW before you can use it in a program.
For the details of the installation, see @ref{Installation and
Customization}.)

We recommend that you read this tutorial in order.@footnote{You can
read the tutorial in bit-reversed order after computing your first
transform.}  At the least, read the first section (@pxref{Complex
One-Dimensional DFTs}) before reading any of the others, even if your
main interest lies in one of the other transform types.

@c ------------------------------------------------------------
@node Complex One-Dimensional DFTs, Complex Multi-Dimensional DFTs, Tutorial, Tutorial
@section Complex One-Dimensional DFTs

@quotation
Plan: To bother about the best method of accomplishing an accidental result.
[Ambrose Bierce, @cite{The Enlarged Devil's Dictionary}.]
@cindex Devil
@end quotation

The basic usage of FFTW is simple, and typically looks like:

@example
#include <fftw3.h>
...
@{
    fftw_complex *in, *out;
    fftw_plan p;
    ...
    in = fftw_malloc(sizeof(fftw_complex) * N);
    out = fftw_malloc(sizeof(fftw_complex) * N);
    p = fftw_plan_dft_1d(N, in, out, FFTW_FORWARD, FFTW_ESTIMATE);
    ...
    fftw_execute(p);
    ...
    fftw_destroy_plan(p);
    fftw_free(in); fftw_free(out);
@}
@end example

(When you compile, you must also link with the fftw3 library,
e.g. @code{-lfftw3 -lm} on Unix systems.)

First, of course, you allocate the arrays; you can do this any way that
you like, but we recommend using @code{fftw_malloc}, which behaves the
same as @code{malloc} except that it properly aligns the array when SIMD
acceleration is available (@pxref{The Importance of Alignment}).  The
data is an array of type @code{fftw_complex}, which is by default a
@code{double[2]} containing the real (@code{in[i][0]}) and imaginary
(@code{in[i][1]}) parts.  If you have a C compiler, such as @code{gcc},
supporting the recent C99 standard, and you @code{#include <complex.h>}
@emph{before} @code{<fftw3.h>}, then @code{fftw_complex} is the native
double-precision complex type and you can manipulate it with ordinary
arithmetic.  (To use the C++ @code{<complex>} template class, see the
FFTW FAQ.)  Single and long-double precision versions of FFTW may also
be installed; to use them, replace the @code{fftw_} prefix by
@code{fftwf_} or @code{fftwl_} and link with @code{-lfftw3f} or
@code{-lfftw3l}, but use the @emph{same} @code{<fftw3.h>} header file.

The next thing is to create a @dfn{plan}, which is an object
@cindex plan
that contains all the data that FFTW needs to compute the FFT, using the
following function:

@example
fftw_plan fftw_plan_dft_1d(int n, fftw_complex *in, fftw_complex *out,
                           int sign, unsigned flags);
@end example
@findex fftw_plan_dft_1d
@tindex fftw_plan

The first argument, @code{n}, is the size of the transform you are
trying to compute.  The size @code{n} can be any positive integer, but
sizes that are products of small factors are transformed most
efficiently.  The next two arguments are the input and output arrays
of the transform; they can be the same, indicating an @dfn{in-place}
transform. 
@cindex in-place
The fourth argument, @code{sign}, can be either @code{FFTW_FORWARD}
(@code{-1}) or @code{FFTW_BACKWARD} (@code{+1}),
@ctindex FFTW_FORWARD
@ctindex FFTW_BACKWARD
and indicates the direction of the transform you are interested in;
technically, it is the sign of the exponent in the transform.  The
@code{flags} argument is usually either @code{FFTW_MEASURE} or
@cindex flags
@code{FFTW_ESTIMATE}.  @code{FFTW_MEASURE} means that FFTW actually
runs
@ctindex FFTW_MEASURE
and measures the execution time of several FFTs in order to find the
best way to compute the transform of size @code{n}.  This will take
some time (usually a few seconds), depending on your machine and on
the size of the transform.  @code{FFTW_ESTIMATE}, on the contrary,
does not run any computation and just builds a
@ctindex FFTW_ESTIMATE
reasonable plan that is probably sub-optimal.  In other words, if your
program performs many transforms of the same size and initialization
time is not important, use @code{FFTW_MEASURE}; otherwise use the
estimate.  The data in the @code{in}/@code{out} arrays is
@emph{overwritten} during @code{FFTW_MEASURE} planning, so such
planning should be done @emph{before} the input is initialized by the
user.  (There are other options too; see @ref{FFTW Reference}.  For
example, use @code{FFTW_PATIENT} if you're willing to wait even longer
for a more optimal plan.
@ctindex FFTW_PATIENT
One can also save plans for future use, as described by @ref{Words of
Wisdom}.)

Once the plan has been created, you can use it as many times as you
like for transforms on the specified @code{in}/@code{out} arrays,
computing the actual transforms via @code{fftw_execute(plan)}.  If you
@cindex execute
want to transform a @emph{different} array of the same size, you can
create a new plan with @code{fftw_plan_dft_1d} and FFTW will
automatically reuse the information from the previous plan, if
possible.  (Alternatively, there is a guru interface for applying a
given plan to a different array, if sufficient care is taken.
@xref{FFTW Reference}.)

When you are done with the plan, you deallocate it by calling
@code{fftw_destroy_plan(plan)}.
@findex fftw_destroy_plan
Arrays allocated with @code{fftw_malloc} should be deallocated by
@code{fftw_free} rather than the ordinary @code{free} (or, heaven
forbid, @code{delete}).

The DFT results are stored in-order in the array @code{out}, with the
zero-frequency (DC) component in @code{out[0]}.
@cindex frequency
The array @code{in} is not modified for an @dfn{out-of-place}
@cindex out-of-place
transform (@code{in != out}).  Users should note that FFTW computes an
@emph{unnormalized} DFT.  Thus, computing a forward followed by a
backward transform (or vice versa) results in the original array
scaled by @code{n}.  For the definition of the DFT, see @ref{What FFTW
Really Computes}.
@cindex DFT
@cindex normalization

@c ------------------------------------------------------------
@node Complex Multi-Dimensional DFTs, One-Dimensional DFTs of Real Data, Complex One-Dimensional DFTs, Tutorial
@section Complex Multi-Dimensional DFTs

Multi-dimensional transforms work much the same way as one-dimensional
transforms: you allocate arrays of @code{fftw_complex} (preferably
using @code{fftw_malloc}), create an @code{fftw_plan}, execute it as
many times as you want with @code{fftw_execute(plan)}, and clean up
with @code{fftw_destroy_plan(plan)} (and @code{fftw_free}).  The only
difference is the routine you use to create the plan:

@example
fftw_plan fftw_plan_dft_2d(int nx, int ny,
                           fftw_complex *in, fftw_complex *out,
                           int sign, unsigned flags);
fftw_plan fftw_plan_dft_3d(int nx, int ny, int nz,
                           fftw_complex *in, fftw_complex *out,
                           int sign, unsigned flags);
fftw_plan fftw_plan_dft(int rank, const int *n,
                        fftw_complex *in, fftw_complex *out,
                        int sign, unsigned flags);
@end example
@findex fftw_plan_dft_2d
@findex fftw_plan_dft_3d
@findex fftw_plan_dft

These routines create plans for @code{nx} by @code{ny} two-dimensional
(2d) transforms, @code{nx} by @code{ny} by @code{nz} 3d transforms,
and arbitrary @code{rank}-dimensional transforms, respectively.  In the
@cindex rank
third case, @code{n} is a pointer to an array @code{n[rank]} denoting
an @code{n[0]} by @code{n[1]} by @dots{} by @code{n[rank-1]}
transform.  All of these transforms operate on contiguous arrays in
the C-standard @dfn{row-major} order, so that the last dimension has
the fastest-varying index in the array; this is described further in
@ref{Multi-dimensional Array Format}.

You might have noticed that all the planner routines so far have
overlapping functionality.  For example, you can plan a 1d or 2d
transform by using @code{fftw_plan_dft} with a @code{rank} of @code{1}
or @code{2}, or even by calling @code{fftw_plan_dft_3d} with @code{nx}
and/or @code{ny} equal to @code{1} (with no loss in efficiency).  This
pattern continues, and FFTW's planning routines in general form a
``partial order,'' sequences of
@cindex partial order
interfaces with strictly increasing generality but correspondingly
greater complexity.

@code{fftw_plan_dft} is the most general complex-DFT routine that we
describe in this tutorial, but there are also the advanced and guru interfaces,
@cindex advanced interface
@cindex guru interface 
which allow one to efficiently combine multiple/strided transforms
into a single FFTW plan, transform a subset of a larger
multi-dimensional array, and/or to handle more general complex-number
formats.  For more information, see @ref{FFTW Reference}.

@c ------------------------------------------------------------
@node One-Dimensional DFTs of Real Data, Multi-Dimensional DFTs of Real Data, Complex Multi-Dimensional DFTs, Tutorial
@section One-Dimensional DFTs of Real Data

In many practical applications, the input data @code{in[i]} are purely
real numbers, in which case the DFT output satisfies the ``Hermitian''
@cindex Hermitian
redundancy: @code{out[i]} is the conjugate of @code{out[n-i]}.  It is
possible to take advantage of these circumstances in order to achieve
roughly a factor of two improvement in both speed and memory usage.

In exchange for these speed and space advantages, the user sacrifices
some of the simplicity of FFTW's complex transforms. First of all, the
input and output arrays are of different sizes and types: the input is
@code{n} real numbers, while the output is @code{n/2+1} complex
numbers; this requires slight ``padding'' of the input array for
@cindex padding
in-place transforms.  Second, the inverse transform (complex to real)
has the side-effect of destroying its input array, by default.  Neither
of these inconveniences should pose a serious problem for users, but
it is important to be aware of them.

The routines to perform real-data transforms are almost the same as
those for complex transforms: you allocate arrays of @code{double}
and/or @code{fftw_complex} (preferably using @code{fftw_malloc}),
create an @code{fftw_plan}, execute it as many times as you want with
@code{fftw_execute(plan)}, and clean up with
@code{fftw_destroy_plan(plan)} (and @code{fftw_free}).  The only
differences are that the input (or output) is of type @code{double},
and there are new routines to create the plan:

@example
fftw_plan fftw_plan_dft_r2c_1d(int n, double *in, fftw_complex *out,
                               unsigned flags);
fftw_plan fftw_plan_dft_c2r_1d(int n, fftw_complex *in, double *out,
                               unsigned flags);
@end example
@findex fftw_plan_dft_r2c_1d
@findex fftw_plan_dft_c2r_1d

Here, @code{n} is the ``logical'' size of the DFT, not necessarily the
physical size of the array.  In particular, the real (@code{double})
array has @code{n} elements, while the complex (@code{fftw_complex})
array has @code{n/2+1} elements (where @samp{@code{/}} denotes C
integer division, truncating for odd @code{n}).  For an in-place transform,
@cindex in-place
@code{in} and @code{out} are aliased to the same array, which must be
big enough to hold both; so, the real array would actually have
@code{2*(n/2+1)} elements, where the elements beyond the first
@code{n} are unused padding.  (For single/long-double precision
@code{fftwf} and @code{fftwl}, @code{double} should be replaced by
@code{float} and @code{long double}, respectively.)

Unlike the complex DFT planner, there is no @code{sign} argument.
Instead, r2c DFTs are always @code{FFTW_FORWARD} and c2r DFTs are
always @code{FFTW_BACKWARD}.
@ctindex FFTW_FORWARD
@ctindex FFTW_BACKWARD

As noted above, the c2r transform destroys its input array even for
out-of-place transforms.  This can be prevented, if necessary, by
including @code{FFTW_PRESERVE_INPUT} in the @code{flags}, with
unfortunately some sacrifice in performance.
@cindex flags
@ctindex FFTW_PRESERVE_INPUT

Readers familiar with DFTs of real data will recall that the 0th (DC)
and @code{n/2}-th (Nyquist, for even @code{n}) elements of the complex
output are purely real.  Some implementations therefore store the
Nyquist element where the DC imaginary part would go, in order to make
the input and output arrays the same size.  Such packing, however,
does not generalize well to multidimensional transforms, and the space
savings are miniscule in any case.

An alternate interface for one-dimensional r2c and c2r DFTs can be
found in the @samp{r2r} interface (@pxref{The Halfcomplex-format
DFT}), with ``halfcomplex''-format output that @emph{is} the same size
(and type) as the input array.
@cindex halfcomplex format
That interface, although it does not generalize well to
multidimensional transforms, may sometimes yield better performance.

@c ------------------------------------------------------------
@node Multi-Dimensional DFTs of Real Data, More DFTs of Real Data, One-Dimensional DFTs of Real Data, Tutorial
@section Multi-Dimensional DFTs of Real Data

Multi-dimensional DFTs to/from real data use the following planner routines:

@example
fftw_plan fftw_plan_dft_r2c_2d(int nx, int ny,
                               double *in, fftw_complex *out,
                               unsigned flags);
fftw_plan fftw_plan_dft_r2c_3d(int nx, int ny, int nz,
                               double *in, fftw_complex *out,
                               unsigned flags);
fftw_plan fftw_plan_dft_r2c(int rank, const int *n,
                            double *in, fftw_complex *out,
                            unsigned flags);
@end example
@findex fftw_plan_dft_r2c_2d
@findex fftw_plan_dft_r2c_3d
@findex fftw_plan_dft_r2c

as well as the corresponding @code{c2r} routines with the input/output
types swapped.  These routines work similarly to their complex
analogues, except for the fact that here the complex output array is
cut in ~half and the real array requires padding for in-place
transforms (as in 1d, above).

As before, @code{n} etc. specify the logical size of the transform.
For an out-of-place transform, this is the same as the physical size
of the @emph{real} array, but the complex array has its @emph{last}
dimension @emph{nlast} cut roughly in half to @emph{nlast}/2+1.

To be continued...

@c ------------------------------------------------------------
@node More DFTs of Real Data,  , Multi-Dimensional DFTs of Real Data, Tutorial
@section More DFTs of Real Data
@menu
* The Halfcomplex-format DFT::  
* Real even/odd DFTs (cosine/sine transforms)::  
* The Discrete Hartley Transform::  
@end menu

@c =========>
@node The Halfcomplex-format DFT, Real even/odd DFTs (cosine/sine transforms), More DFTs of Real Data, More DFTs of Real Data
@subsection The Halfcomplex-format DFT

@c =========>
@node Real even/odd DFTs (cosine/sine transforms), The Discrete Hartley Transform, The Halfcomplex-format DFT, More DFTs of Real Data
@subsection Real even/odd DFTs (cosine/sine transforms)

@c =========>
@node The Discrete Hartley Transform,  , Real even/odd DFTs (cosine/sine transforms), More DFTs of Real Data
@subsection The Discrete Hartley Transform

Okay, so this is not really a DFT, but it's close.


@c ************************************************************
@node Other Stuff You Should Know, FFTW Reference, Tutorial, Top
@chapter Other Stuff You Should Know
@menu
* The Importance of Alignment::  
* Multi-dimensional Array Format::  
* Words of Wisdom::             
@end menu

@c ------------------------------------------------------------
@node The Importance of Alignment, Multi-dimensional Array Format, Other Stuff You Should Know, Other Stuff You Should Know
@section The Importance of Alignment
@cindex alignment

@c ------------------------------------------------------------
@node Multi-dimensional Array Format, Words of Wisdom, The Importance of Alignment, Other Stuff You Should Know
@section Multi-dimensional Array Format

@c ------------------------------------------------------------
@node Words of Wisdom,  , Multi-dimensional Array Format, Other Stuff You Should Know
@section Words of Wisdom
@cindex wisdom
@cindex saving plans to disk

@c ************************************************************
@node FFTW Reference, Parallel FFTW, Other Stuff You Should Know, Top
@chapter FFTW Reference
@menu
* Basic Interface::             
* Advanced Interface::          
* Guru Interface::              
* What FFTW Really Computes::   
@end menu

@c ------------------------------------------------------------
@node Basic Interface, Advanced Interface, FFTW Reference, FFTW Reference
@section Basic Interface
@cindex basic interface

@c ------------------------------------------------------------
@node Advanced Interface, Guru Interface, Basic Interface, FFTW Reference
@section Advanced Interface
@cindex advanced interface

@c ------------------------------------------------------------
@node Guru Interface, What FFTW Really Computes, Advanced Interface, FFTW Reference
@section Guru Interface
@cindex guru interface


@c ------------------------------------------------------------
@node What FFTW Really Computes,  , Guru Interface, FFTW Reference
@section What FFTW Really Computes
@cindex discrete Fourier transform
@cindex DFT


@c ************************************************************
@node Parallel FFTW, Calling FFTW from Fortran, FFTW Reference, Top
@chapter Parallel FFTW

@c ************************************************************
@node Calling FFTW from Fortran, Installation and Customization, Parallel FFTW, Top
@chapter Calling FFTW from Fortran

@c ************************************************************
@node Installation and Customization, Acknowledgments, Calling FFTW from Fortran, Top
@chapter Installation and Customization

@c ************************************************************
@node Acknowledgments, License and Copyright, Installation and Customization, Top
@chapter Acknowledgments

@c ************************************************************
@node License and Copyright, Concept Index, Acknowledgments, Top
@chapter License and Copyright


FFTW is Copyright @copyright{} 2002 Matteo Frigo, Copyright
@copyright{} 2002 Steven G. Johnson.

FFTW is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.  You can also
find the @uref{http://www.gnu.org/copyleft/gpl.html, GPL on the GNU web
site}.

In addition, we kindly ask you to acknowledge FFTW and its authors in
any program or publication in which you use FFTW.  (You are not
@emph{required} to do so; it is up to your common sense to decide
whether you want to comply with this request or not.)  For general
publications, we suggest referencing: Matteo Frigo and Steven
G. Johnson, ``FFTW: An adaptive software architecture for the FFT,''
Proc. ICASSP 1998, vol. 3, p. 1381--1384.

Non-free versions of FFTW are available under terms different than the
General Public License. (e.g. they do not require you to accompany any
object code using FFTW with the corresponding source code.)  For these
alternate terms you must purchase a license from MIT's Technology
Licensing Office.  Users interested in such a license should contact us
(@email{fftw@@fftw.org}) for more information.


@node Concept Index, Library Index, License and Copyright, Top
@chapter Concept Index
@printindex cp

@node Library Index,  , Concept Index, Top
@chapter Library Index
@printindex fn

@c ************************************************************
@contents

@bye

