\input texinfo    @c -*-texinfo-*-
@comment $Id: fftw3.texi,v 1.51 2003-03-01 00:01:20 stevenj Exp $
@comment %**start of header
@setfilename fftw3.info
@include version.texi
@settitle FFTW @value{VERSION}
@setchapternewpage odd
@c define constant index (ct)
@defcodeindex ct
@syncodeindex ct fn
@syncodeindex vr fn
@syncodeindex pg fn
@syncodeindex tp fn
@c define foreign function index (ff)
@defcodeindex ff
@syncodeindex ff cp
@c define foreign constant index (fc)
@defcodeindex fc
@syncodeindex fc cp
@c define foreign program index (fp)
@defcodeindex fp
@syncodeindex fp cp
@comment %**end of header

@macro Onlogn
@ifinfo
O(n log n)
@end ifinfo
@ifhtml
<i>O</i>(<i>n</i>&nbsp;log&nbsp;<i>n</i>)
@end ifhtml
@tex
$O(n \\log n)$
@end tex
@end macro

@copying
This manual is for FFTW
(version @value{VERSION}, @value{UPDATED}).

Copyright @copyright{} 2002 Matteo Frigo.

Copyright @copyright{} 2002 Steven G. Johnson.

@quotation
Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end quotation
@end copying

@dircategory Texinfo documentation system
@direntry
* fftw3: (fftw3)FFTW User's Manual.
@end direntry

@titlepage
@title FFTW
@subtitle for version @value{VERSION}, @value{UPDATED}
@author{Matteo Frigo}
@author{Steven G. Johnson}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top, Introduction, (dir), (dir)
@top FFTW User Manual
Welcome to FFTW, the Fastest Fourier Transform in the West.  FFTW is a
collection of fast C routines to compute the discrete Fourier transform.
This manual documents FFTW version @value{VERSION}.
@end ifnottex

@menu
* Introduction::                
* Tutorial::                    
* Other Stuff You Should Know::  
* FFTW Reference::              
* Parallel FFTW::               
* Calling FFTW from Fortran::   
* Installation and Customization::  
* Acknowledgments::             
* License and Copyright::       
* Concept Index::               
* Library Index::               Tutorial


Other Stuff You Should Know

@end menu

@c ************************************************************
@node    Introduction, Tutorial, Top, Top
@chapter Introduction
This manual documents version @value{VERSION} of FFTW, the @emph{Fastest
Fourier Transform in the West}.  FFTW is a comprehensive collection of
fast C routines for computing the discrete Fourier transform (DFT) in
@cindex discrete Fourier transform
@cindex DFT
one or more dimensions, of both real and complex data, and of arbitrary
input size.  It also includes specialized transforms for real even/odd
data (a.k.a. discrete cosine/sine transforms), as well as the discrete
Hartley transform (DHT).  We assume herein that the reader is already
familiar with the properties and uses of the DFT that are relevant to
her application.  Otherwise, see e.g. @cite{The Fast Fourier Transform}
by E. O. Brigham (Prentice-Hall, Englewood Cliffs, NJ, 1974).
@uref{http://www.fftw.org, Our web page} also has links to FFT-related
information online.
@cindex FFTW

FFTW @value{VERSION} also includes parallel (multi-threaded) transforms
for shared-memory systems.  We currently provide distributed-memory
parallel (MPI) transforms separately, as part of FFTW 2.x.

FFTW is usually faster (and sometimes much faster) than all other
freely-available Fourier transform programs found on the Net.  It is
competitive with (and often faster than) the FFT codes in Sun's
Performance Library, IBM's ESSL library, HP's CXML library, and Intel's
MKL library, which are targeted at specific machines.  Moreover, FFTW's
performance is @emph{portable}.  Indeed, FFTW is unique in that it
automatically adapts itself to your machine, your cache, the size of
your memory, your number of registers, and all the other factors that
normally make it impossible to optimize a program for more than one
machine.  An extensive comparison of FFTW's performance with that of
other Fourier transform codes has been made, and the results are
available on the Web at @uref{http://fftw.org/~benchfft, the benchFFT
home page}.
@cindex benchmark
@fpindex benchfft

In order to use FFTW effectively, you need to understand one basic
concept of FFTW's internal structure:  FFTW does not used a fixed
algorithm for computing the transform, but instead can adapt the DFT
algorithm to details of the underlying hardware in order to achieve
the best performance.  Hence, the computation of the transform is
split into two phases.  First, FFTW's @dfn{planner} is called, which
``learns'' the fastest way to compute the transform on your machine.
The planner
@cindex planner
produces a data structure called a @dfn{plan} that contains this
@cindex plan
information.  Subsequently, the plan is @dfn{executed}
@cindex execute
to transform the array of input data as dictated by the plan.  The plan
can be reused as many times as needed.  In typical high-performance
applications, many transforms of the same size are computed, and
consequently a relatively-expensive initialization of this sort is
acceptable.  On the other hand, if you need a single transform of a
given size, the one-time cost of the planner becomes significant.  For
this case, FFTW provides fast planners based on heuristics or on
previously computed plans (``wisdom'').
@cindex wisdom

This pattern of planning/execution applies to all transform types
supported by FFTW; each type comes with its own planner routine to
specify the problem to be solved.  Because FFTW is very flexible in the
layout and multiplicity of the data to be transformed, these planner
routines are organized into three categories: the @dfn{basic interface}
for computing single transforms of contiguous data; the @dfn{advanced
interface} for efficient transforms of multiple/strided arrays; and the
@dfn{guru} interface, which supports the most general data
layouts/multiplicities/strides.  We expect that most users will be best
served by the basic interface, whereas the guru interface requires
careful attention to the documentation to avoid problems.
@cindex basic interface
@cindex advanced interface
@cindex guru interface 

Besides the automatic performance adaptation performed by the planner,
it is also possible for advanced users to customize FFTW for their
special needs.  For example, we provide a tool so that users who only
require a limited set of transform types/sizes can link to just those
parts of FFTW that are required for the optimal plans, greatly reducing
the size of statically linked executables.  Moreover, as distributed,
FFTW works most efficiently for arrays whose size can be factored into
small primes (@math{2}, @math{3}, @math{5}, and @math{7}), and uses a
slower general-purpose routine for other factors.  FFTW, however, comes
with a code generator that can produce fast C programs for any
particular array size you may care about.
@cindex code generator
For example, if you need transforms of size
@ifinfo
@math{513 = 19 x 3^3},
@end ifinfo
@tex
$513 = 19 \cdot 3^3$,
@end tex
@ifhtml
513&nbsp;=&nbsp;19*3<sup>3</sup>,
@end ifhtml
you can customize FFTW to support the factor @math{19} efficiently.

For more information regarding FFTW, see the paper, ``FFTW: An
adaptive software architecture for the FFT,'' by M. Frigo and
S. G. Johnson, which appeared in the 23rd International Conference on
Acoustics, Speech, and Signal Processing (@cite{Proc. ICASSP 1998}
@b{3}, p. 1381).  See also, ``The Fastest Fourier Transform in the
West,'' by M. Frigo and S. G. Johnson, which is the technical report
MIT-LCS-TR-728 (Sep. '97).  The code generator is described in the
paper ``A fast Fourier transform compiler'',
@cindex compiler
by M. Frigo, in the @cite{Proceedings of the 1999 ACM SIGPLAN Conference
on Programming Language Design and Implementation (PLDI), Atlanta,
Georgia, May 1999}.  These papers, along with the latest version of
FFTW, the FAQ, benchmarks, and other links, are available at
@uref{http://www.fftw.org, the FFTW home page}.  The current version of
FFTW incorporates many good ideas from the past thirty years of FFT
literature.  In one way or another, FFTW uses the Cooley-Tukey
algorithm, the Prime Factor algorithm, Rader's algorithm for prime
sizes, and the split-radix algorithm (with a variation due to Dan
Bernstein).  Our code generator also produces new algorithms that we do
not yet completely understand.
@cindex algorithm
The reader is referred to the cited papers for the appropriate
references.

The rest of this manual is organized as follows.  We first discuss the
sequential (single-processor) implementation.  We start by describing the
basic interface/features of FFTW in @ref{Tutorial}.  The following
chapter discusses @ref{Other Stuff You Should Know}, including
@ref{The Importance of Alignment}, the storage scheme of
multi-dimensional arrays (@pxref{Multi-dimensional Array Format}), and
FFTW's mechanism for storing plans on disk (@pxref{Words of Wisdom}).
Next, @ref{FFTW Reference} provides comprehensive documentation of all
FFTW's features.  Parallel transforms are discussed in their own
chapter @ref{Parallel FFTW}.  Fortran programmers can also use FFTW,
as described in @ref{Calling FFTW from Fortran}.  @ref{Installation
and Customization} explains how to install FFTW in your computer
system and how to adapt FFTW to your needs.  License and copyright
information is given in @ref{License and Copyright}.  Finally, we
thank all the people who helped us in @ref{Acknowledgments}.

@c ************************************************************
@node  Tutorial, Other Stuff You Should Know, Introduction, Top
@chapter Tutorial
@menu
* Complex One-Dimensional DFTs::  
* Complex Multi-Dimensional DFTs::  
* One-Dimensional DFTs of Real Data::  
* Multi-Dimensional DFTs of Real Data::  
* More DFTs of Real Data::      
@end menu

This chapter describes the basic usage of FFTW, i.e., how to compute
@cindex basic interface
the Fourier transform of a single array.  This chapter tells the
truth, but not the @emph{whole} truth. Specifically, FFTW implements
additional routines and flags that are not documented here, although
in many cases we try to indicate where added capabilities exist.  For
more complete information, see @ref{FFTW Reference}.  (Note that you
need to compile and install FFTW before you can use it in a program.
For the details of the installation, see @ref{Installation and
Customization}.)

We recommend that you read this tutorial in order.@footnote{You can
read the tutorial in bit-reversed order after computing your first
transform.}  At the least, read the first section (@pxref{Complex
One-Dimensional DFTs}) before reading any of the others, even if your
main interest lies in one of the other transform types.

@c ------------------------------------------------------------
@node Complex One-Dimensional DFTs, Complex Multi-Dimensional DFTs, Tutorial, Tutorial
@section Complex One-Dimensional DFTs

@quotation
Plan: To bother about the best method of accomplishing an accidental result.
[Ambrose Bierce, @cite{The Enlarged Devil's Dictionary}.]
@cindex Devil
@end quotation

The basic usage of FFTW to compute a one-dimensional DFT of size
@code{N} is simple, and typically looks something like:

@example
#include <fftw3.h>
...
@{
    fftw_complex *in, *out;
    fftw_plan p;
    ...
    in = fftw_malloc(sizeof(fftw_complex) * N);
    out = fftw_malloc(sizeof(fftw_complex) * N);
    p = fftw_plan_dft_1d(N, in, out, FFTW_FORWARD, FFTW_ESTIMATE);
    ...
    fftw_execute(p);
    ...
    fftw_destroy_plan(p);
    fftw_free(in); fftw_free(out);
@}
@end example

(When you compile, you must also link with the fftw3 library,
e.g. @code{-lfftw3 -lm} on Unix systems.)

First, of course, you allocate the arrays; you can do this any way that
you like, but we recommend using @code{fftw_malloc}, which behaves the
same as @code{malloc} except that it properly aligns the array when SIMD
acceleration is available (@pxref{The Importance of Alignment}).  The
data is an array of type @code{fftw_complex}, which is by default a
@code{double[2]} containing the real (@code{in[i][0]}) and imaginary
(@code{in[i][1]}) parts.  If you have a C compiler, such as @code{gcc},
supporting the recent C99 standard, and you @code{#include <complex.h>}
@emph{before} @code{<fftw3.h>}, then @code{fftw_complex} is the native
double-precision complex type and you can manipulate it with ordinary
arithmetic.  (To use the C++ @code{<complex>} template class, see the
FFTW FAQ.)  Single and long-double precision versions of FFTW may also
be installed; to use them, replace the @code{fftw_} prefix by
@code{fftwf_} or @code{fftwl_} and link with @code{-lfftw3f} or
@code{-lfftw3l}, but use the @emph{same} @code{<fftw3.h>} header file.

The next thing is to create a @dfn{plan}, which is an object
@cindex plan
that contains all the data that FFTW needs to compute the FFT, using the
following function:

@example
fftw_plan fftw_plan_dft_1d(int n, fftw_complex *in, fftw_complex *out,
                           int sign, unsigned flags);
@end example
@findex fftw_plan_dft_1d
@tindex fftw_plan

The first argument, @code{n}, is the size of the transform you are
trying to compute.  The size @code{n} can be any positive integer, but
sizes that are products of small factors are transformed most
efficiently (although prime sizes still use an @Onlogn
algorithm).  The next two arguments are the input and output arrays of
the transform; they can be the same, indicating an @dfn{in-place}
transform.
@cindex in-place
The fourth argument, @code{sign}, can be either @code{FFTW_FORWARD}
(@code{-1}) or @code{FFTW_BACKWARD} (@code{+1}),
@ctindex FFTW_FORWARD
@ctindex FFTW_BACKWARD
and indicates the direction of the transform you are interested in;
technically, it is the sign of the exponent in the transform.  The
@code{flags} argument is usually either @code{FFTW_MEASURE} or
@cindex flags
@code{FFTW_ESTIMATE}.  @code{FFTW_MEASURE} means that FFTW actually
runs
@ctindex FFTW_MEASURE
and measures the execution time of several FFTs in order to find the
best way to compute the transform of size @code{n}.  This will take
some time (usually a few seconds), depending on your machine and on
the size of the transform.  @code{FFTW_ESTIMATE}, on the contrary,
does not run any computation and just builds a
@ctindex FFTW_ESTIMATE
reasonable plan that is probably sub-optimal.  In other words, if your
program performs many transforms of the same size and initialization
time is not important, use @code{FFTW_MEASURE}; otherwise use the
estimate.  The data in the @code{in}/@code{out} arrays is
@emph{overwritten} during @code{FFTW_MEASURE} planning, so such
planning should be done @emph{before} the input is initialized by the
user.  (There are other options too; see @ref{FFTW Reference}.  For
example, use @code{FFTW_PATIENT} if you're willing to wait even longer
for a more optimal plan.
@ctindex FFTW_PATIENT
One can also save plans for future use, as described by @ref{Words of
Wisdom}.)

@example
void fftw_execute(const fftw_plan plan);
@end example
@findex fftw_execute

Once the plan has been created, you can use it as many times as you
like for transforms on the specified @code{in}/@code{out} arrays,
computing the actual transforms via @code{fftw_execute(plan)}.  If you
@cindex execute
want to transform a @emph{different} array of the same size, you can
create a new plan with @code{fftw_plan_dft_1d} and FFTW will
automatically reuse the information from the previous plan, if
possible.  (Alternatively, there is a guru interface for applying a
given plan to a different array, if sufficient care is taken.
@xref{FFTW Reference}.)

@example
void fftw_destroy_plan(fftw_plan plan);
@end example
@findex fftw_destroy_plan

When you are done with the plan, you deallocate it by calling
@code{fftw_destroy_plan(plan)}.
@findex fftw_destroy_plan
Arrays allocated with @code{fftw_malloc} should be deallocated by
@code{fftw_free} rather than the ordinary @code{free} (or, heaven
forbid, @code{delete}).

The DFT results are stored in-order in the array @code{out}, with the
zero-frequency (DC) component in @code{out[0]}.
@cindex frequency
The array @code{in} is not modified for an @dfn{out-of-place}
@cindex out-of-place
transform (@code{in != out}).  Users should note that FFTW computes an
@emph{unnormalized} DFT.  Thus, computing a forward followed by a
backward transform (or vice versa) results in the original array
scaled by @code{n}.  For the definition of the DFT, see @ref{What FFTW
Really Computes}.
@cindex DFT
@cindex normalization

@c ------------------------------------------------------------
@node Complex Multi-Dimensional DFTs, One-Dimensional DFTs of Real Data, Complex One-Dimensional DFTs, Tutorial
@section Complex Multi-Dimensional DFTs

Multi-dimensional transforms work much the same way as one-dimensional
transforms: you allocate arrays of @code{fftw_complex} (preferably
using @code{fftw_malloc}), create an @code{fftw_plan}, execute it as
many times as you want with @code{fftw_execute(plan)}, and clean up
with @code{fftw_destroy_plan(plan)} (and @code{fftw_free}).  The only
difference is the routine you use to create the plan:

@example
fftw_plan fftw_plan_dft_2d(int nx, int ny,
                           fftw_complex *in, fftw_complex *out,
                           int sign, unsigned flags);
fftw_plan fftw_plan_dft_3d(int nx, int ny, int nz,
                           fftw_complex *in, fftw_complex *out,
                           int sign, unsigned flags);
fftw_plan fftw_plan_dft(int rank, const int *n,
                        fftw_complex *in, fftw_complex *out,
                        int sign, unsigned flags);
@end example
@findex fftw_plan_dft_2d
@findex fftw_plan_dft_3d
@findex fftw_plan_dft

These routines create plans for @code{nx} by @code{ny} two-dimensional
(2d) transforms, @code{nx} by @code{ny} by @code{nz} 3d transforms,
and arbitrary @code{rank}-dimensional transforms, respectively.  In the
@cindex rank
third case, @code{n} is a pointer to an array @code{n[rank]} denoting
an @code{n[0]} by @code{n[1]} by @dots{} by @code{n[rank-1]}
transform.  All of these transforms operate on contiguous arrays in
the C-standard @dfn{row-major} order, so that the last dimension has
the fastest-varying index in the array; this is described further in
@ref{Multi-dimensional Array Format}.

You might have noticed that all the planner routines so far have
overlapping functionality.  For example, you can plan a 1d or 2d
transform by using @code{fftw_plan_dft} with a @code{rank} of @code{1}
or @code{2}, or even by calling @code{fftw_plan_dft_3d} with @code{nx}
and/or @code{ny} equal to @code{1} (with no loss in efficiency).  This
pattern continues, and FFTW's planning routines in general form a
``partial order,'' sequences of
@cindex partial order
interfaces with strictly increasing generality but correspondingly
greater complexity.

@code{fftw_plan_dft} is the most general complex-DFT routine that we
describe in this tutorial, but there are also the advanced and guru interfaces,
@cindex advanced interface
@cindex guru interface 
which allow one to efficiently combine multiple/strided transforms
into a single FFTW plan, transform a subset of a larger
multi-dimensional array, and/or to handle more general complex-number
formats.  For more information, see @ref{FFTW Reference}.

@c ------------------------------------------------------------
@node One-Dimensional DFTs of Real Data, Multi-Dimensional DFTs of Real Data, Complex Multi-Dimensional DFTs, Tutorial
@section One-Dimensional DFTs of Real Data

In many practical applications, the input data @code{in[i]} are purely
real numbers, in which case the DFT output satisfies the ``Hermitian''
@cindex Hermitian
redundancy: @code{out[i]} is the conjugate of @code{out[n-i]}.  It is
possible to take advantage of these circumstances in order to achieve
roughly a factor of two improvement in both speed and memory usage.

In exchange for these speed and space advantages, the user sacrifices
some of the simplicity of FFTW's complex transforms. First of all, the
input and output arrays are of @emph{different sizes and types}: the
input is @code{n} real numbers, while the output is @code{n/2+1}
complex numbers (the non-redundant outputs); this also requires slight
``padding'' of the input array for
@cindex padding
in-place transforms.  Second, the inverse transform (complex to real)
has the side-effect of @emph{destroying its input array}, by default.
Neither of these inconveniences should pose a serious problem for
users, but it is important to be aware of them.

The routines to perform real-data transforms are almost the same as
those for complex transforms: you allocate arrays of @code{double}
and/or @code{fftw_complex} (preferably using @code{fftw_malloc}),
create an @code{fftw_plan}, execute it as many times as you want with
@code{fftw_execute(plan)}, and clean up with
@code{fftw_destroy_plan(plan)} (and @code{fftw_free}).  The only
differences are that the input (or output) is of type @code{double}
and there are new routines to create the plan.  In one dimension:

@example
fftw_plan fftw_plan_dft_r2c_1d(int n, double *in, fftw_complex *out,
                               unsigned flags);
fftw_plan fftw_plan_dft_c2r_1d(int n, fftw_complex *in, double *out,
                               unsigned flags);
@end example
@findex fftw_plan_dft_r2c_1d
@findex fftw_plan_dft_c2r_1d

for the real input to complex-Hermitian output (@dfn{r2c}) and
complex-Hermitian input to real output (@dfn{c2r}) transforms.
@cindex r2c
@cindex c2r
Unlike the complex DFT planner, there is no @code{sign} argument.
Instead, r2c DFTs are always @code{FFTW_FORWARD} and c2r DFTs are
always @code{FFTW_BACKWARD}.
@ctindex FFTW_FORWARD
@ctindex FFTW_BACKWARD
(For single/long-double precision
@code{fftwf} and @code{fftwl}, @code{double} should be replaced by
@code{float} and @code{long double}, respectively.)

Here, @code{n} is the ``logical'' size of the DFT, not necessarily the
physical size of the array.  In particular, the real (@code{double})
array has @code{n} elements, while the complex (@code{fftw_complex})
array has @code{n/2+1} elements (where the division is rounded down).
For an in-place transform,
@cindex in-place
@code{in} and @code{out} are aliased to the same array, which must be
big enough to hold both; so, the real array would actually have
@code{2*(n/2+1)} elements, where the elements beyond the first @code{n}
are unused padding.  The @math{k}th element of the complex array is
exactly the same as the @math{k}th element of the corresponding complex
DFT.  All positive @code{n} are supported; products of small factors are
most efficient, but an @Onlogn algorithm is used even for prime
sizes.

As noted above, the c2r transform destroys its input array even for
out-of-place transforms.  This can be prevented, if necessary, by
including @code{FFTW_PRESERVE_INPUT} in the @code{flags}, with
unfortunately some sacrifice in performance.
@cindex flags
@ctindex FFTW_PRESERVE_INPUT
This flag is also not currently supported for multi-dimensional real
DFTs (next section).

Readers familiar with DFTs of real data will recall that the 0th (DC)
and @code{n/2}-th (Nyquist, for even @code{n}) elements of the complex
output are purely real.  Some implementations therefore store the
Nyquist element where the DC imaginary part would go, in order to make
the input and output arrays the same size.  Such packing, however, does
not generalize well to multi-dimensional transforms, and the space
savings are miniscule in any case.

An alternate interface for one-dimensional r2c and c2r DFTs can be
found in the @samp{r2r} interface (@pxref{The Halfcomplex-format
DFT}), with ``halfcomplex''-format output that @emph{is} the same size
(and type) as the input array.
@cindex halfcomplex format
That interface, although it is not very useful for multi-dimensional
transforms, may sometimes yield better performance.

@c ------------------------------------------------------------
@node Multi-Dimensional DFTs of Real Data, More DFTs of Real Data, One-Dimensional DFTs of Real Data, Tutorial
@section Multi-Dimensional DFTs of Real Data

Multi-dimensional DFTs of real data use the following planner routines:

@example
fftw_plan fftw_plan_dft_r2c_2d(int nx, int ny,
                               double *in, fftw_complex *out,
                               unsigned flags);
fftw_plan fftw_plan_dft_r2c_3d(int nx, int ny, int nz,
                               double *in, fftw_complex *out,
                               unsigned flags);
fftw_plan fftw_plan_dft_r2c(int rank, const int *n,
                            double *in, fftw_complex *out,
                            unsigned flags);
@end example
@findex fftw_plan_dft_r2c_2d
@findex fftw_plan_dft_r2c_3d
@findex fftw_plan_dft_r2c

as well as the corresponding @code{c2r} routines with the input/output
types swapped.  These routines work similarly to their complex
analogues, except for the fact that here the complex output array is cut
roughly in half and the real array requires padding for in-place
transforms (as in 1d, above).

As before, @code{n} is the logical size of the array, and the
consequences of this on the the format of the complex arrays deserve
careful attention.
@cindex r2c/c2r multi-dimensional array format
Suppose that the real data has dimensions
@tex
$n_1 \times n_2 \times \cdots \times n_d$
@end tex
@ifinfo
n1 x n2 x ... x nd
@end ifinfo
@ifhtml
n<sub>1</sub> x n<sub>2</sub> x ... x n<sub>d</sub>
@end ifhtml
(in row-major order).  Then, after an r2c transform, the
output is an
@tex
$n_1 \times n_2 \times \cdots \times (n_d/2+1)$
@end tex
@ifinfo
n1 x n2 x ... x (nd/2+1)
@end ifinfo
@ifhtml
n<sub>1</sub> x n<sub>2</sub> x ... x (n<sub>d</sub>/2+1)
@end ifhtml
array of @code{fftw_complex} values in row-major order, corresponding to
slightly over half of the output of the corresponding complex DFT.  (The
division is rounded down.)  The ordering of the data is otherwise
exactly the same as in the complex-DFT case.

Since the complex data is slightly larger than the real data, some
complications arise for in-place transforms.  In this case, the final
dimension of the real data must be padded with extra values to
accommodate the size of the complex data---two extra if the last
dimension is even and one if it is odd.
@cindex padding
That is, the last dimension of the real data must physically contain
@tex
$2 (n_d/2+1)$
@end tex
@ifinfo
2 * (nd/2+1)
@end ifinfo
@ifhtml
2 * (n<sub>d</sub>/2+1)
@end ifhtml
@code{double} values (exactly enough to hold the complex data).
This physical array size does not, however, change the @emph{logical}
array size---only
@tex
$n_d$
@end tex
@ifinfo
nd
@end ifinfo
@ifhtml
n<sub>d</sub>
@end ifhtml
values are actually stored in the last dimension, and
@tex
$n_d$
@end tex
@ifinfo
nd
@end ifinfo
@ifhtml
n<sub>d</sub>
@end ifhtml
is the last dimension passed to the plan-creation routine.

For example, consider the transform of a two-dimensional real array of
size @code{nx} by @code{ny}.  The output of the r2c transform is a
two-dimensional complex array of size @code{nx} by @code{ny/2+1}, where
the @code{y} dimension has been cut nearly in half because of
redundancies in the output.  Because @code{fftw_complex} is twice the
size of @code{double}, the output array is slightly bigger than the
input array.  Thus, if we want to compute the transform in place, we
must @emph{pad} the input array so that it is of size @code{nx} by
@code{2*(ny/2+1)}.  If @code{ny} is even, then there are two padding
elements at the end of each row (which need not be initialized, as they
are only used for output).
@ifhtml
The following illustration depicts the input and output arrays just
described, for both the out-of-place and in-place transforms (with the
arrows indicating consecutive memory locations):

<p align=center><img src="rfftwnd.gif" width=389 height=583>
@end ifhtml

@tex
Figure 1 depicts the input and output arrays just
described, for both the out-of-place and in-place transforms (with the
arrows indicating consecutive memory locations).

{
\pageinsert
\vfill
\vskip405pt
\hskip40pt
\special{psfile="rfftwnd.eps" 
}
\vskip 24pt
Figure 1: Illustration of the data layout for real to complex (r2c)
transforms.  
\vfill
\endinsert}
@end tex

These transforms are unnormalized, so an r2c followed by a c2r
transform (or vice versa) will result in the original data scaled by
the number of real data elements---that is, the product of the
(logical) dimensions of the real data.
@cindex normalization

(Because the last dimension is treated specially, if it is equal to
@code{1} the transform is @emph{not} equivalent to a lower-dimensional
r2c/c2r transform.  In that case, the last complex dimension also has
size @code{1} (@code{=1/2+1}), and no advantage is gained over the
complex transforms.)

@c ------------------------------------------------------------
@node More DFTs of Real Data,  , Multi-Dimensional DFTs of Real Data, Tutorial
@section More DFTs of Real Data
@menu
* The Halfcomplex-format DFT::  
* Real even/odd DFTs (cosine/sine transforms)::  
* The Discrete Hartley Transform::  
@end menu

FFTW supports several other transform types via a unified @dfn{r2r}
(real-to-real) interface,
@cindex r2r
so-called because it takes a real (@code{double}) array and outputs a
real array of the same size.  These r2r transforms currently fall into
three categories: DFTs of real input and complex-Hermitian output in
halfcomplex format, DFTs of real input with even/odd symmetry
(a.k.a. discrete cosine/sine transforms, DCTs/DSTs), and discrete
Hartley transforms (DHTs), all described in more detail by the
following sections.

The r2r transforms follow the by-now familiar interface of creating an
@code{fftw_plan}, executing it with @code{fftw_execute(plan)}, and
destroying it with @code{fftw_destroy_plan(plan)}.  Furthermore, all
r2r transforms share the same planner interface:

@example
fftw_plan fftw_plan_r2r_1d(int n, double *in, double *out,
                           fftw_r2r_kind kind, unsigned flags);
fftw_plan fftw_plan_r2r_2d(int nx, int ny, double *in, double *out,
                           fftw_r2r_kind kindx, fftw_r2r_kind kindy,
                           unsigned flags);
fftw_plan fftw_plan_r2r_3d(int nx, int ny, int nz,
                           double *in, double *out,
                           fftw_r2r_kind kindx,
                           fftw_r2r_kind kindy,
                           fftw_r2r_kind kindz,
                           unsigned flags);
fftw_plan fftw_plan_r2r(int rank, const int *n, double *in, double *out,
                        const fftw_r2r_kind *kind, unsigned flags);
@end example
@findex fftw_plan_r2r_1d
@findex fftw_plan_r2r_2d
@findex fftw_plan_r2r_3d
@findex fftw_plan_r2r

Just as for the complex DFT, these plan 1d/2d/3d/multi-dimensional
transforms for contiguous arrays in row-major order, transforming (real)
input to output of the same size, where @code{n} specifies the
@emph{physical} dimensions of the arrays.  All positive @code{n} are
supported (with the exception of @code{n=1} for the @code{FFTW_REDFT00}
kind, noted in the real-even subsection below); products of small
factors are most efficient (factorizing @code{n-1} and @code{n+1} for
@code{FFTW_REDFT00} and @code{FFTW_RODFT00} kinds, described below), but
an @Onlogn algorithm is used even for prime sizes.

Each dimension has a @dfn{kind} parameter, of type
@code{fftw_r2r_kind}, specifying the kind of r2r transform to be used
for that dimension.
@cindex kind (r2r)
@tindex fftw_r2r_kind
(In the case of @code{fftw_plan_r2r}, this is an array @code{kind[rank]}
where @code{kind[i]} is the transform kind for the dimension
@code{n[i]}.)  The kind can be one of a set of predefined constants,
defined in the following subsections.

That is, FFTW computes the separable product of the specified r2r
transforms over each dimension, which can be used e.g. for partial
differential equations with mixed boundary conditions.  (For some r2r
kinds, notably the halfcomplex DFT and the DHT, such a separable
product is somewhat problematic in more than one dimension, however,
as is described below.)

In the current version of FFTW, all r2r transforms except for the
halfcomplex type are computed via pre-/post-processing of halfcomplex
transforms, and are therefore not entirely optimal.  Since most other
general DCT/DST codes employ the same trick, however, FFTW's
implementation should provide at least competitive performance.

@c =========>
@node The Halfcomplex-format DFT, Real even/odd DFTs (cosine/sine transforms), More DFTs of Real Data, More DFTs of Real Data
@subsection The Halfcomplex-format DFT

An r2r kind of @code{FFTW_R2HC} (@dfn{r2hc})corresponds to an r2c DFT
@ctindex FFTW_R2HC
@cindex r2c
@cindex r2hc
(@pxref{One-Dimensional DFTs of Real Data}) but with ``halfcomplex''
format output, and may sometimes be faster than the latter.
@cindex halfcomplex format
The inverse @dfn{hc2r} transform is of kind @code{FFTW_HC2R}.
@ctindex FFTW_HC2R
@cindex hc2r
This consists of the non-redundant half of the complex output for a 1d
real-input DFT of size @code{n}, stored as a sequence of @code{n} real
numbers (@code{double}) in the format:

@tex
$$
r_0, r_1, r_2, \ldots, r_{n/2}, i_{(n+1)/2-1}, \ldots, i_2, i_1
$$
@end tex
@ifinfo
r0, r1, r2, r(n/2), i((n+1)/2-1), ..., i2, i1
@end ifinfo
@ifhtml
<p align=center>
r<sub>0</sub>, r<sub>1</sub>, r<sub>2</sub>, ..., r<sub>n/2</sub>, i<sub>(n+1)/2-1</sub>, ..., i<sub>2</sub>, i<sub>1</sub>
</p>
@end ifhtml

Here,
@ifinfo
rk
@end ifinfo
@tex
$r_k$
@end tex
@ifhtml
r<sub>k</sub>
@end ifhtml
is the real part of the @math{k}th output, and
@ifinfo
ik
@end ifinfo
@tex
$i_k$
@end tex
@ifhtml
i<sub>k</sub>
@end ifhtml
is the imaginary part.  (Division by 2 is rounded down.) For a
halfcomplex array @code{hc[n]}, the @math{k}th component thus has its
real part in @code{hc[k]} and its imaginary part in @code{hc[n-k]}, with
the exception of @code{k} @code{==} @code{0} or @code{n/2} (the latter
only if @code{n} is even)---in these two cases, the imaginary part is
zero due to symmetries of the real-input DFT, and is not stored.
Thus, the r2hc transform of @code{n} real values is a halfcomplex array of
length @code{n}, and vice versa for hc2r.
@cindex normalization

Aside from the differing format, the output of
@code{FFTW_R2HC}/@code{FFTW_HC2R} is otherwise exactly the same as for
the corresponding 1d r2c/c2r transform
(i.e. @code{FFTW_FORWARD}/@code{FFTW_BACKWARD} transforms, respectively).
Recall that these transforms are unnormalized, so r2hc followed by hc2r
will result in the original data multiplied by @code{n}.  Furthermore,
like the c2r transform, an out-of-place hc2r transform will
@emph{destroy its input} array.

Although these halfcomplex transforms can be used with the
multi-dimensional r2r interface, the interpretation of such a separable
product of transforms along each dimension is problematic.  For example,
consider a two-dimensional @code{nx} by @code{ny}, r2hc by r2hc
transform planned by @code{fftw_plan_r2r_2d(nx, ny, in, out, FFTW_R2HC,
FFTW_R2HC, FFTW_MEASURE)}.  Conceptually, FFTW first transforms the rows
(of size @code{ny}) to produce halfcomplex rows, and then transforms the
columns (of size @code{nx}).  Half of these column transforms, however,
are of imaginary parts, and should therefore be multiplied by @math{i}
and combined with the r2hc transforms of the real columns to produce the
2d DFT amplitudes; FFTW's r2r transform does @emph{not} perform this
combination for you.  Thus, if a multi-dimensional real-input/output DFT
is required, we recommend using the ordinary r2c/c2r
interface (@pxref{Multi-Dimensional DFTs of Real Data}).

@c =========>
@node Real even/odd DFTs (cosine/sine transforms), The Discrete Hartley Transform, The Halfcomplex-format DFT, More DFTs of Real Data
@subsection Real even/odd DFTs (cosine/sine transforms)

The Fourier transform of a real-even function @math{f(-x) = f(x)} is
real-even, and @math{i} times the Fourier transform of a real-odd
function @math{f(-x) = -f(x)} is real-odd.  Similar results hold for a
discrete Fourier transform, and thus for these symmetries the need for
complex inputs/outputs is entirely eliminated.  Moreover, one gains a
factor of two in speed/space from the fact that the data are real, and
an additional factor of two from the even/odd symmetry.  The result is
the real-even DFT (@dfn{REDFT}) and the real-odd DFT (@dfn{RODFT}), also
known as the discrete cosine and sine transforms (@dfn{DCT} and @dfn{DST}),
respectively.
@cindex real-even DFT
@cindex REDFT
@cindex real-odd DFT
@cindex RODFT
@cindex discrete cosine transform
@cindex DCT
@cindex discrete sine transform
@cindex DST

(In this section, we describe the 1d transforms; multi-dimensional
transforms are just a separable product of these transforms operating
along each dimension.)

Because of the discrete sampling, one has an additional choice: is the
data even/odd around a sampling point, or around the point halfway
between two samples?  The latter corresponds to @emph{shifting} the
samples by @emph{half} an interval, and gives rise to several transform
variants denoted by REDFT@math{ab} and RODFT@math{ab}: @math{a} and
@math{b} are @math{0} or @math{1}, and indicate whether the input
(@math{a}) and/or output (@math{b}) are shifted by half a sample
(@math{1} means it is shifted).  These are also known as types I-IV of
the DCT and DST, and all four types are supported by FFTW's r2r
interface.@footnote{There are also type V-VIII transforms, which
correspond to a logical DFT of @emph{odd} size @math{N}, independent of
whether the physical size @code{n} is odd, but we do not support these
variants.}

The r2r kinds for the various REDFT and RODFT types supported by FFTW,
along with the boundary conditions at both ends of the @emph{input}
array@footnote{Note that the boundary conditions of the transform output
array are given by the input boundary conditions of the inverse
transform.} (@code{n} real numbers @code{in[j=0..n-1]}), are:

@itemize @bullet

@item
@code{FFTW_REDFT00} (DCT-I): even around @math{j=0} and even around @math{j=n-1}.
@ctindex FFTW_REDFT00

@item
@code{FFTW_REDFT10} (DCT-II): even around @math{j=-0.5} and even around @math{j=n-0.5}.
@ctindex FFTW_REDFT10

@item
@code{FFTW_REDFT01} (DCT-III): even around @math{j=0} and odd around @math{j=n}.
@ctindex FFTW_REDFT01

@item
@code{FFTW_REDFT11} (DCT-IV): even around @math{j=-0.5} and odd around @math{j=n-0.5}.
@ctindex FFTW_REDFT11

@item
@code{FFTW_RODFT00} (DST-I): odd around @math{j=-1} and odd around @math{j=n}.
@ctindex FFTW_RODFT00

@item
@code{FFTW_RODFT10} (DST-II): odd around @math{j=-0.5} and odd around @math{j=n-0.5}.
@ctindex FFTW_RODFT10

@item
@code{FFTW_RODFT01} (DST-III): odd around @math{j=-1} and even around @math{j=n-1}.
@ctindex FFTW_RODFT01

@item
@code{FFTW_RODFT11} (DST-IV): odd around @math{j=-0.5} and even around @math{j=n-0.5}.
@ctindex FFTW_RODFT11

@end itemize

All of these transforms are invertible.  The inverse of R*DFT00 is
R*DFT00; of R*DFT10 is R*DFT01 and vice versa; and of R*DFT11 is
R*DFT11.  However, the transforms computed by FFTW are unnormalized,
exactly like the corresponding real and complex DFTs, so computing a
transform followed by its inverse yields the original array scaled by
@math{N}, where @math{N} is the @emph{logical} DFT size.  For REDFT00,
@math{N=2(n-1)}; for RODFT00, @math{N=2(n+1)}; otherwise, @math{N=2n}.
@cindex normalization

FFTW is most efficient when @math{N} is a product of small factors; note
that this @emph{differs} from the factorization of the physical size
@code{n} for REDFT00 and RODFT00!  There is another oddity: @code{n=1}
REDFT00 transforms correspond to @math{N=0}, and so are @emph{not
defined} (the planner will return @code{NULL}).  Otherwise, any positive
@code{n} is supported.

For the precise mathematical definitions of these transforms as used by
FFTW, see @ref{What FFTW Really Computes}.  (For people accustomed to the
DCT/DST, FFTW's definitions have a coefficient of @math{2} in front of
the cos/sin functions so that they correspond precisely to an even/odd
DFT of size @math{N}.)

@c =========>
@node The Discrete Hartley Transform,  , Real even/odd DFTs (cosine/sine transforms), More DFTs of Real Data
@subsection The Discrete Hartley Transform

The discrete Hartley transform (DHT) is an invertible linear transform
closely related to the DFT.  In the DFT, one multiplies each input by
cos - i sin (a complex exponential), whereas in the DHT each input is
multiplied by simply cos + sin.  Thus, the DHT transforms @code{n} real
numbers to @code{n} real numbers, and has the convenient property of
being its own inverse.  In FFTW, a DHT (of any positive @code{n}) can be
specified by an r2r kind of @code{FFTW_DHT}.
@ctindex FFTW_DHT
@cindex discrete Hartley transform
@cindex DHT

Like the DFT, in FFTW the DHT is unnormalized, so computing a DHT of
size @code{n} followed by another DHT of the same size will result in
the original array multiplied by @code{n}.
@cindex normalization

The DHT was originally proposed as a more-efficient alternative to the
DFT for real data, but it was subsequently shown that a specialized DFT
(such as FFTW's r2hc or r2c transforms) could be just as fast.  In FFTW,
the DHT is actually computed by post-processing an r2hc transform, so
there is ordinarily no reason to prefer it from a performance
perspective.@footnote{We provide the DHT mainly as a byproduct of some
internal algorithms. FFTW computes a real input/output DFT of
@emph{prime} size by re-expressing it as a DHT plus post/pre-processing
and then using Rader's prime-DFT algorithm adapted to the DHT.}
However, we have heard that the DHT might be the most appropriate
transform in its own right for certain applications, and we would be
very interested to hear from anyone who finds it useful.

If @code{FFTW_DHT} is specified for multiple dimensions of a
multi-dimensional transform, FFTW computes the separable product of 1d
DHTs along each dimension.  Unfortunately, this is not quite the same
thing as a true multi-dimensional DHT; you can compute the latter, if
necessary, with at most @code{rank-1} post-processing passes
[see e.g. H. Hao and R. N. Bracewell, @i{Proc. IEEE} @b{75}, 264--266 (1987)].

For the precise mathematical definition of the DHT as used by FFTW, see
@ref{What FFTW Really Computes}.

@c ************************************************************
@node Other Stuff You Should Know, FFTW Reference, Tutorial, Top
@chapter Other Stuff You Should Know
@menu
* The Importance of Alignment::  
* Multi-dimensional Array Format::  
* Words of Wisdom::             
@end menu

@c ------------------------------------------------------------
@node The Importance of Alignment, Multi-dimensional Array Format, Other Stuff You Should Know, Other Stuff You Should Know
@section The Importance of Alignment
@cindex alignment

@c ------------------------------------------------------------
@node Multi-dimensional Array Format, Words of Wisdom, The Importance of Alignment, Other Stuff You Should Know
@section Multi-dimensional Array Format

@c ------------------------------------------------------------
@node Words of Wisdom,  , Multi-dimensional Array Format, Other Stuff You Should Know
@section Words of Wisdom
@cindex wisdom
@cindex saving plans to disk

@c ************************************************************
@node FFTW Reference, Parallel FFTW, Other Stuff You Should Know, Top
@chapter FFTW Reference
@menu
* Basic Interface::             
* Advanced Interface::          
* Guru Interface::              
* What FFTW Really Computes::   
@end menu

@c ------------------------------------------------------------
@node Basic Interface, Advanced Interface, FFTW Reference, FFTW Reference
@section Basic Interface
@cindex basic interface

@c ------------------------------------------------------------
@node Advanced Interface, Guru Interface, Basic Interface, FFTW Reference
@section Advanced Interface
@cindex advanced interface

@c ------------------------------------------------------------
@node Guru Interface, What FFTW Really Computes, Advanced Interface, FFTW Reference
@section Guru Interface
@cindex guru interface


@c ------------------------------------------------------------
@node What FFTW Really Computes,  , Guru Interface, FFTW Reference
@section What FFTW Really Computes
@cindex discrete Fourier transform
@cindex DFT


@c ************************************************************
@node Parallel FFTW, Calling FFTW from Fortran, FFTW Reference, Top
@chapter Parallel FFTW

@c ************************************************************
@node Calling FFTW from Fortran, Installation and Customization, Parallel FFTW, Top
@chapter Calling FFTW from Fortran

@c ************************************************************
@node Installation and Customization, Acknowledgments, Calling FFTW from Fortran, Top
@chapter Installation and Customization

@c ************************************************************
@node Acknowledgments, License and Copyright, Installation and Customization, Top
@chapter Acknowledgments

@c ************************************************************
@node License and Copyright, Concept Index, Acknowledgments, Top
@chapter License and Copyright


FFTW is Copyright @copyright{} 2002 Matteo Frigo, Copyright
@copyright{} 2002 Steven G. Johnson.

FFTW is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.  You can also
find the @uref{http://www.gnu.org/copyleft/gpl.html, GPL on the GNU web
site}.

In addition, we kindly ask you to acknowledge FFTW and its authors in
any program or publication in which you use FFTW.  (You are not
@emph{required} to do so; it is up to your common sense to decide
whether you want to comply with this request or not.)  For general
publications, we suggest referencing: Matteo Frigo and Steven
G. Johnson, ``FFTW: An adaptive software architecture for the FFT,''
Proc. ICASSP 1998, vol. 3, p. 1381--1384.

Non-free versions of FFTW are available under terms different from those
of the General Public License. (e.g. they do not require you to
accompany any object code using FFTW with the corresponding source
code.)  For these alternate terms you must purchase a license from MIT's
Technology Licensing Office.  Users interested in such a license should
contact us (@email{fftw@@fftw.org}) for more information.


@node Concept Index, Library Index, License and Copyright, Top
@chapter Concept Index
@printindex cp

@node Library Index,  , Concept Index, Top
@chapter Library Index
@printindex fn

@c ************************************************************
@contents

@bye

