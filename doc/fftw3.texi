\input texinfo    @c -*-texinfo-*-
@comment $Id: fftw3.texi,v 1.4 2003-01-18 22:13:51 stevenj Exp $
@comment %**start of header
@setfilename fftw3.info
@include version.texi
@settitle FFTW @value{VERSION}
@setchapternewpage odd
@c define constant index (ct)
@defcodeindex ct
@syncodeindex ct fn
@syncodeindex vr fn
@syncodeindex pg fn
@syncodeindex tp fn
@c define foreign function index (ff)
@defcodeindex ff
@syncodeindex ff cp
@c define foreign constant index (fc)
@defcodeindex fc
@syncodeindex fc cp
@c define foreign program index (fp)
@defcodeindex fp
@syncodeindex fp cp
@comment %**end of header

@copying
This manual is for FFTW
(version @value{VERSION}, @value{UPDATED}).

Copyright @copyright{} 2002 Matteo Frigo.

Copyright @copyright{} 2002 Steven G. Johnson.

@quotation
Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end quotation
@end copying

@dircategory Texinfo documentation system
@direntry
* fftw3: (fftw3)FFTW User's Manual.
@end direntry

@titlepage
@title FFTW
@subtitle for version @value{VERSION}, @value{UPDATED}
@author{Matteo Frigo}
@author{Steven G. Johnson}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top, Introduction, (dir), (dir)
@top FFTW User Manual
Welcome to FFTW, the Fastest Fourier Transform in the West.  FFTW is a
collection of fast C routines to compute the discrete Fourier transform.
This manual documents FFTW version @value{VERSION}.
@end ifnottex

@menu
* Introduction::                
* Tutorial::                    
* Other Stuff You Should Know::  
* FFTW Reference::              
* Parallel FFTW::               
* Calling FFTW from Fortran::   
* Installation and Customization::  
* Acknowledgments::             
* License and Copyright::       
* Concept Index::               
* Library Index::               Tutorial


Other Stuff You Should Know

@end menu

@c ************************************************************
@node    Introduction, Tutorial, Top, Top
@chapter Introduction
This manual documents version @value{VERSION} of FFTW, the @emph{Fastest
Fourier Transform in the West}.  FFTW is a comprehensive collection of
fast C routines for computing the discrete Fourier transform (DFT) in
one or more dimensions, of both real and complex data, and of arbitrary
input size.  It also includes specialized transforms for real even/odd
data (a.k.a. discrete cosine/sine transforms), as well as the discrete
Hartley transform (DHT).  We assume herein that the reader is already
familiar with the properties and uses of the DFT that are relevant to
her application.  Otherwise, see e.g. @cite{The Fast Fourier Transform}
by E. O. Brigham (Prentice-Hall, Englewood Cliffs, NJ, 1974).
@uref{http://www.fftw.org, Our web page} also has links to FFT-related
information online.
@cindex FFTW

FFTW @value{VERSION} also includes parallel (multi-threaded) transforms
for shared-memory systems.  We currently provide distributed-memory
parallel (MPI) transforms separately, as part of FFTW 2.x.

FFTW is usually faster (and sometimes much faster) than all other
freely-available Fourier transform programs found on the Net.  It is
competitive with (and often faster than) the FFT codes in Sun's
Performance Library, IBM's ESSL library, HP's CXML library, and Intel's
MKL library, which are targeted at specific machines.  Moreover, FFTW's
performance is @emph{portable}.  Indeed, FFTW is unique in that it
automatically adapts itself to your machine, your cache, the size of
your memory, the number of registers, and all the other factors that
normally make it impossible to optimize a program for more than one
machine.  An extensive comparison of FFTW's performance with that of
other Fourier transform codes has been made, and the results are
available on the Web at @uref{http://fftw.org/~benchfft, the benchFFT
home page}.
@cindex benchmark
@fpindex benchfft

In order to use FFTW effectively, you need to understand one basic
concept of FFTW's internal structure.  FFTW does not used a fixed
algorithm for computing the transform, but it can adapt the DFT
algorithm to details of the underlying hardware in order to achieve best
performance.  Hence, the computation of the transform is split into two
phases.  First, FFTW's @dfn{planner} is called, which ``learns'' the
@cindex plan
fastest way to compute the transform on your machine.  The planner
@cindex planner
produces a data structure called a @dfn{plan} that contains this
information.  Subsequently, the plan is @dfn{executed}
@cindex execute
to transform the array of input data as dictated by the plan.  The plan
can be reused as many times as needed.  In typical high-performance
applications, many transforms of the same size are computed, and
consequently a relatively-expensive initialization of this sort is
acceptable.  On the other hand, if you need a single transform of a
given size, the one-time cost of the planner becomes significant.  For
this case, FFTW provides fast planners based on heuristics or on
previously computed plans (``wisdom'').
@cindex wisdom

The pattern of planning/execution applies to all transform types
supported by FFTW; each type comes with its own planner routine to
specify the problem to be solved.  Because FFTW is very flexible in the
layout and multiplicity of the data to be transformed, these planner
routines are organized into three categories: the @dfn{basic interface}
for computing single transforms of contiguous data; the @dfn{advanced
interface} for efficient transforms of multiple/strided arrays; and the
@dfn{guru} interface, which supports the most general data
layouts/multiplicities/strides.  We expect that most users will be best
served by the basic interface, whereas the guru interface requires
careful attention to the documentation to avoid problems.
@cindex basic interface
@cindex advanced interface
@cindex guru interface 

Besides the automatic performance adaptation performed by the planner,
it is also possible for advanced users to customize FFTW for their
special needs.  For example, we provide a tool so that users who only
require a limited set of transform types/sizes can link to just those
parts of FFTW that are required for the optimal plans, greatly reducing
the size of statically linked executables.  Moreover, as distributed,
FFTW works most efficiently for arrays whose size can be factored into
small primes (@math{2}, @math{3}, @math{5}, and @math{7}), and uses a
slower general-purpose routine for other factors.  FFTW, however, comes
with a code generator that can produce fast C programs for any
particular array size you may care about.
@cindex code generator
For example, if you need transforms of size
@ifinfo
@math{513 = 19 x 3^3},
@end ifinfo
@tex
$513 = 19 \cdot 3^3$,
@end tex
@ifhtml
513&nbsp;=&nbsp;19*3<sup>3</sup>,
@end ifhtml
you can customize FFTW to support the factor @math{19} efficiently.

For more information regarding FFTW, see the paper, ``FFTW: An
Adaptive Software Architecture for the FFT,'' by M. Frigo and
S. G. Johnson, which appeared in the 23rd International Conference on
Acoustics, Speech, and Signal Processing (@cite{Proc. ICASSP 1998}
@b{3}, p. 1381).  See also, ``The Fastest Fourier Transform in the
West,'' by M. Frigo and S. G. Johnson, which is the technical report
MIT-LCS-TR-728 (Sep. '97).  The code generator is described in the
paper ``A Fast Fourier Transform Compiler'',
@cindex compiler
by M. Frigo, in the @cite{Proceedings of the 1999 ACM SIGPLAN Conference
on Programming Language Design and Implementation (PLDI), Atlanta,
Georgia, May 1999}.  These papers, along with the latest version of
FFTW, the FAQ, benchmarks, and other links, are available at
@uref{http://www.fftw.org, the FFTW home page}.  The current version of
FFTW incorporates many good ideas from the past thirty years of FFT
literature.  In one way or another, FFTW uses the Cooley-Tukey
algorithm, the Prime Factor algorithm, Rader's algorithm for prime
sizes, and the split-radix algorithm (with a variation due to Dan
Bernstein).  Our code generator also produces new algorithms that we do
not yet completely understand.
@cindex algorithm
The reader is referred to the cited papers for the appropriate
references.

The rest of this manual is organized as follows.  We first discuss the
sequential (one-processor) implementation.  We start by describing the
basic interface/features of FFTW in @ref{Tutorial}.  The following
chapter discusses @ref{Other Stuff You Should Know}, including
@ref{The Importance of Alignment}, the storage scheme of
multi-dimensional arrays (@ref{Multi-dimensional Array Format}), and
FFTW's mechanism for storing plans on disk (@ref{Words of Wisdom}).
Next, @ref{FFTW Reference} provides comprehensive documentation of all
FFTW's features.  Parallel transforms are discussed in their own
chapter @ref{Parallel FFTW}.  Fortran programmers can also use FFTW,
as described in @ref{Calling FFTW from Fortran}.  @ref{Installation
and Customization} explains how to install FFTW in your computer
system and how to adapt FFTW to your needs.  License and copyright
information is given in @ref{License and Copyright}.  Finally, we
thank all the people who helped us in @ref{Acknowledgments}.

@c ************************************************************
@node  Tutorial, Other Stuff You Should Know, Introduction, Top
@chapter Tutorial
@menu
* Complex One-Dimensional Transforms::  
@end menu

@c ------------------------------------------------------------
@node Complex One-Dimensional Transforms,  , Tutorial, Tutorial
@section Complex One-Dimensional Transforms

The basic usage of FFTW is simple, and typically looks like:

@example
#include <fftw3.h>
...
@{
    fftw_complex *in, *out;
    fftw_plan p;
    ...
    in = fftw_malloc(sizeof(fftw_complex) * N);
    out = fftw_malloc(sizeof(fftw_complex) * N);
    p = fftw_plan_dft_1d(N, in, out, FFTW_FORWARD, FFTW_ESTIMATE);
    ...
    fftw_execute(p);
    ...
    fftw_destroy_plan(p);
    fftw_free(in); fftw_free(out);
@}
@end example

(When you compile, you must also link with the fftw3 library,
e.g. @code{-lfftw3 -lm} on Unix systems.)

First, of course, you allocate the arrays; you can do this any way that
you like, but we recommend using @code{fftw_malloc}, which behaves the
same as @code{malloc} except that it properly aligns the array when SIMD
acceleration is available (@pxref{The Importance of Alignment}).  The
data is an array of type @code{fftw_complex}, which is by default an
array @code{double[2]} containing the real (@code{in[i][0]}) and
imaginary (@code{in[i][1]}) parts.  If you have a C compiler, such as
@code{gcc}, supporting the latest C99 standard, and you @code{#include
<complex.h>} @emph{before} @code{<fftw3.h>}, then @code{fftw_complex} is
the native double-precision complex type and you can manipulate it with
ordinary arithmetic.  (To use the C++ @code{<complex>} template class,
see the FFTW FAQ.)  Single and long-double precision versions of FFTW
may also be available, with the @code{fftw_} prefix replaced by
@code{fftwf_} or @code{fftwl_} and linking with @code{-lfftw3f} or
@code{-lfftw3l}, but using the same @code{<fftw3.h>} header file.

@c ************************************************************
@node Other Stuff You Should Know, FFTW Reference, Tutorial, Top
@chapter Other Stuff You Should Know
@menu
* The Importance of Alignment::  
* Multi-dimensional Array Format::  
* Words of Wisdom::             
@end menu

@c ------------------------------------------------------------
@node The Importance of Alignment, Multi-dimensional Array Format, Other Stuff You Should Know, Other Stuff You Should Know
@section The Importance of Alignment
@cindex alignment

@c ------------------------------------------------------------
@node Multi-dimensional Array Format, Words of Wisdom, The Importance of Alignment, Other Stuff You Should Know
@section Multi-dimensional Array Format

@c ------------------------------------------------------------
@node Words of Wisdom,  , Multi-dimensional Array Format, Other Stuff You Should Know
@section Words of Wisdom
@cindex wisdom
@cindex saving plans to disk

@c ************************************************************
@node FFTW Reference, Parallel FFTW, Other Stuff You Should Know, Top
@chapter FFTW Reference
@menu
* Basic Interface::             
* Advanced Interface::          
* Guru Interface::              
@end menu

@c ------------------------------------------------------------
@node Basic Interface, Advanced Interface, FFTW Reference, FFTW Reference
@section Basic Interface
@cindex basic interface

@c ------------------------------------------------------------
@node Advanced Interface, Guru Interface, Basic Interface, FFTW Reference
@section Advanced Interface
@cindex advanced interface

@c ------------------------------------------------------------
@node Guru Interface,  , Advanced Interface, FFTW Reference
@section Guru Interface
@cindex guru interface


@c ************************************************************
@node Parallel FFTW, Calling FFTW from Fortran, FFTW Reference, Top
@chapter Parallel FFTW

@c ************************************************************
@node Calling FFTW from Fortran, Installation and Customization, Parallel FFTW, Top
@chapter Calling FFTW from Fortran

@c ************************************************************
@node Installation and Customization, Acknowledgments, Calling FFTW from Fortran, Top
@chapter Installation and Customization

@c ************************************************************
@node Acknowledgments, License and Copyright, Installation and Customization, Top
@chapter Acknowledgments

@c ************************************************************
@node License and Copyright, Concept Index, Acknowledgments, Top
@chapter License and Copyright


FFTW is Copyright @copyright{} 2002 Matteo Frigo, Copyright
@copyright{} 2002 Steven G. Johnson.

FFTW is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.  You can also
find the @uref{http://www.gnu.org/copyleft/gpl.html, GPL on the GNU web
site}.

In addition, we kindly ask you to acknowledge FFTW and its authors in
any program or publication in which you use FFTW.  (You are not
@emph{required} to do so; it is up to your common sense to decide
whether you want to comply with this request or not.)

Non-free versions of FFTW are available under terms different than the
General Public License. (e.g. they do not require you to accompany any
object code using FFTW with the corresponding source code.)  For these
alternate terms you must purchase a license from MIT's Technology
Licensing Office.  Users interested in such a license should contact us
(@email{fftw@@fftw.org}) for more information.


@node Concept Index, Library Index, License and Copyright, Top
@chapter Concept Index
@printindex cp

@node Library Index,  , Concept Index, Top
@chapter Library Index
@printindex fn

@c ************************************************************
@contents

@bye

