/* -*- C -*- */
#include <stdlib.h>
#include <spu_intrinsics.h>
#include <cbe_mfc.h>
#include <spu_mfcio.h>
#include "fftw-spu.h"
#include "../fftw-cell.h"

#define MAX_DMA_SIZE 16384
static mfc_list_element_t list[MAX_LIST_SZ] 
    __attribute__ ((aligned (ALIGNMENT)));

#define MKLISTENTRY(p, sz, ppu_addr)		\
{						\
     (p)->notify = 0;				\
     (p)->size = (sz);				\
     (p)->eal = (ppu_addr);			\
}

/* universal DMA transfer routine */
void X(spu_dma1d)(void *spu_addr, long long ppu_addr, size_t sz,
		  unsigned int cmdl)
{
     unsigned int tag_id = 0;
     int nlist = 0;

     while (sz > 0) {
	  /* select chunk to align ppu_addr */
	  size_t chunk = ALIGNMENT - (ppu_addr & (ALIGNMENT - 1));

	  /* if already aligned, transfer the whole thing */
	  if (chunk == ALIGNMENT || chunk > sz) 
	       chunk = sz;

	  /* ...up to MAX_DMA_SIZE */
	  if (chunk > MAX_DMA_SIZE) 
	       chunk = MAX_DMA_SIZE;

	  MKLISTENTRY(list + nlist, chunk, ppu_addr);
	  ++nlist;
	  sz -= chunk; ppu_addr += chunk;
     }

     spu_mfcdma32(spu_addr, (unsigned)list, nlist * sizeof(list[0]),
		  tag_id, cmdl);
     spu_mfcstat(2);
}

static void shuffle(R *A, int lda, int r, int c)
{
     int r0 = 0, r1 = r;
     int c0 = 0, c1 = c;
     int dr, dc;
     
 tail:
     dr = r1 - r0;
     dc = c1 - c0;

     if (dc > 0) {
	  if (dr > dc) {
	       X(spu_complex_transpose)(A + r0 * lda + 2 * c0, lda, dc);
	       r0 += dc;
	       goto tail;
	  } else if (dr > 0) {
	       X(spu_complex_transpose)(A + r0 * lda + 2 * c0, lda, dr);
	       c0 += dr;
	       goto tail;
	  }
     }
}

static void transfer(R *A, long long ppu_addr, int ppu_stride_bytes,
		     int r, int c,
		     unsigned int cmdl)
{
     int rx;
     int nlist = 0;
     unsigned int tag_id = 0;
     R *spu_addr = A;

     for (rx = 0; rx < r; ++rx) {
	  int r0 = 0, r1 = r;
	  int c0 = 0, c1 = c;
	  int dr, dc;
     
     tail:
	  dr = r1 - r0;
	  dc = c1 - c0;

	  if (dc > 0) {
	       if (dr > dc) {
		    if (rx < r0 + dc)
			 r1 = r0 + dc;
		    else
			 r0 = r0 + dc;
		    goto tail;
	       } else if (dr > 0) {
		    int cx = c0 + (rx - r0);

		    if (nlist == MAX_LIST_SZ) {
			 spu_mfcdma32(spu_addr, (unsigned)list, 
				      nlist * sizeof(list[0]),
				      tag_id, cmdl);
			 spu_mfcstat(2);
			 spu_addr = A;
			 nlist = 0;
		    }
		    MKLISTENTRY(list + nlist, 
				2 * sizeof(R) * dr,
				ppu_addr + cx * ppu_stride_bytes 
				+ r0 * 2 * sizeof(R));
		    ++nlist;
		    A += 2 * dr;
		    c0 += dr;
		    goto tail;
	       } 
	  }
     }

     if (nlist > 0) {
	  spu_mfcdma32(spu_addr, (unsigned)list, nlist * sizeof(list[0]),
		       tag_id, cmdl);
	  spu_mfcstat(2);
     }
}

/* 2D dma transfer routine, works for 
   ppu_stride_bytes == 2 * sizeof(R) or ppu_vstride_bytes == 2 * sizeof(R) */
void X(spu_dma2d)(R *A, long long ppu_addr, 
		  int n, /* int spu_stride = 2 , */ int ppu_stride_bytes,
		  int v, /* int spu_vstride = 2 * n, */
		  int ppu_vstride_bytes,
		  unsigned int cmdl)
{
     int vv, ii;

     if (ppu_stride_bytes == 2 * sizeof(R)) { 
	  /* contiguous array on the PPU side */

	  /* if the input is a 1D contiguous array, collapse n into v */
	  if (ppu_vstride_bytes == ppu_stride_bytes * n) {
	       n *= v;
	       v = 1;
	  }
	  
	  if (v == 1 || 2 * sizeof(R) * n > MAX_DMA_SIZE) {
	       for (vv = 0; vv < v; ++vv) {
		    X(spu_dma1d)(A, ppu_addr, 2 * sizeof(R) * n, cmdl);
		    A += 2 * n;
		    ppu_addr += ppu_vstride_bytes;
	       }
	  } else {
	       int chunk = MAX_LIST_SZ;
	       unsigned int tag_id = 0;
	       for (vv = 0; vv < v; vv += chunk) {
		    if (chunk > v - vv)
			 chunk = v - vv;

		    for (ii = 0; ii < chunk; ++ii) {
			 MKLISTENTRY(list + ii, 2 * sizeof(R) * n, ppu_addr);
			 ppu_addr += ppu_vstride_bytes;
		    }

		    spu_mfcdma32(A, (unsigned)list, chunk * sizeof(list[0]),
				 tag_id, cmdl);
		    spu_mfcstat(2);

		    A += 2 * n * chunk;
	       }
	  }
     } else { 
	  /* ppu_vstride_bytes == 2 * sizeof(R) */
	  if (cmdl == MFC_PUTL_CMD) 
	       shuffle(A, 2 * n, v, n);

	  transfer(A, ppu_addr, ppu_stride_bytes, v, n, cmdl);

	  if (cmdl == MFC_GETL_CMD) 
	       shuffle(A, 2 * n, v, n);
     }
}
