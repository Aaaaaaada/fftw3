/* -*- C -*- */
#include <stdlib.h>
#include <spu_intrinsics.h>
#include <cbe_mfc.h>
#include <spu_mfcio.h>
#include "fftw-spu.h"
#include "../fftw-cell.h"

#define MAX_DMA_SIZE 16384
#define DMA_WAIT() spu_mfcstat(2)

static void spu_dma1d_nowait(void *spu_addr, long long ppu_addr, size_t sz,
			     unsigned int cmd)
{
     unsigned int tag_id = 0;

     while (sz > 0) {
	  /* select chunk to align ppu_addr */
	  size_t chunk = ALIGNMENT - (ppu_addr & (ALIGNMENT - 1));

	  /* if already aligned, transfer the whole thing */
	  if (chunk == ALIGNMENT || chunk > sz) 
	       chunk = sz;

	  /* ...up to MAX_DMA_SIZE */
	  if (chunk > MAX_DMA_SIZE) 
	       chunk = MAX_DMA_SIZE;

	  spu_mfcdma32(spu_addr, ppu_addr, chunk, tag_id, cmd);
	  sz -= chunk; ppu_addr += chunk; spu_addr += chunk;
     }
}

static void dma2d_contig_nowait(R *A, long long ppu_addr,
				int n, 
				int v, int spu_vstride, int ppu_vstride_bytes,
				unsigned int cmd)
{
     int vv;
     for (vv = 0; vv < v; ++vv) {
	  spu_dma1d_nowait(A, ppu_addr, 2 * sizeof(R) * n, cmd);
	  A += spu_vstride;
	  ppu_addr += ppu_vstride_bytes;
     }
}

void X(spu_dma1d)(void *spu_addr, long long ppu_addr, size_t sz,
		  unsigned int cmd)
{
     spu_dma1d_nowait(spu_addr, ppu_addr, sz, cmd);
     DMA_WAIT();
}

enum operation { DO_DMA, DO_TRANSPOSE };

static void dma2d_transposed(R *A, int lda, 
			     long long ppu_addr, int ppu_stride_bytes,
			     int r, int c,
			     unsigned int cmd, 
			     enum operation op)
{
 tail:
     if (c > 0) {
	  if (r > c) {
	       if (op == DO_DMA)
		    dma2d_contig_nowait(A, ppu_addr,
					c, c, lda, ppu_stride_bytes, cmd);
	       else
		    X(spu_complex_transpose)(A, lda, c);

	       r -= c;
	       A += lda * c;
	       ppu_addr += 2 * sizeof(R) * c;
	       goto tail;
	  } else if (r > 0) {
	       if (op == DO_DMA)
		    dma2d_contig_nowait(A, ppu_addr, 
					r, r, lda, ppu_stride_bytes, cmd);
	       else
		    X(spu_complex_transpose)(A, lda, r);

	       c -= r;
	       A += 2 * r;
	       ppu_addr += ppu_stride_bytes * r;
	       goto tail;
	  }
     }
}

/* 2D dma transfer routine, works for 
   ppu_stride_bytes == 2 * sizeof(R) or ppu_vstride_bytes == 2 * sizeof(R) */
void X(spu_dma2d)(R *A, long long ppu_addr, 
		  int n, /* int spu_stride = 2 , */ int ppu_stride_bytes,
		  int v, /* int spu_vstride = 2 * n, */
		  int ppu_vstride_bytes,
		  unsigned int cmd)
{
     if (ppu_stride_bytes == 2 * sizeof(R)) { 
	  /* contiguous array on the PPU side */

	  /* if the input is a 1D contiguous array, collapse n into v */
	  if (ppu_vstride_bytes == ppu_stride_bytes * n) {
	       n *= v;
	       v = 1;
	  }

	  dma2d_contig_nowait(A, ppu_addr, n, v, 
			      2 * n, ppu_vstride_bytes, cmd);
	  DMA_WAIT();
     } else { 
	  /* ppu_vstride_bytes == 2 * sizeof(R) */
	  if (cmd == MFC_PUT_CMD) 
	       dma2d_transposed(A, 2 * n, ppu_addr, ppu_stride_bytes,
				v, n, cmd, DO_TRANSPOSE);

	  dma2d_transposed(A, 2 * n, ppu_addr, ppu_stride_bytes, 
			   v, n, cmd, DO_DMA);
	  DMA_WAIT();

	  if (cmd == MFC_GET_CMD) 
	       dma2d_transposed(A, 2 * n, ppu_addr, ppu_stride_bytes,
				v, n, cmd, DO_TRANSPOSE);
     }
}
